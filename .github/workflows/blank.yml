#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
#include <atomic>
#include <unistd.h>

// Process structure
struct Process {
    int id;
    std::vector<std::thread> threads;
    bool isSuspended;
    bool isTerminated;
};

// Thread Manager class
class ThreadManager {
private:
    std::vector<Process> processes;
    std::mutex mtx; // Mutex for thread safety

public:
    // Function to create a new process
    void createProcess(int processId) {
        Process newProcess;
        newProcess.id = processId;
        newProcess.isSuspended = false;
        newProcess.isTerminated = false;
        processes.push_back(newProcess);
        std::cout << "Process " << processId << " created." << std::endl;
    }

    // Function to create a new thread in a specific process
    void createThread(int processId, int threadId) {
        mtx.lock(); // Lock the mutex before accessing the shared resource
        processes[processId].threads.emplace_back(&ThreadManager::threadFunction, this, processId, threadId);
        mtx.unlock(); // Unlock the mutex after accessing the shared resource
        std::cout << "Thread " << threadId << " created in Process " << processId << "." << std::endl;
    }

    // Function to start all threads in a specific process
    void startProcessThreads(int processId) {
        Process& process = processes[processId];
        for (auto& thread : process.threads) {
            thread.join();
        }
    }

    // Function to suspend a specific process
    void suspendProcess(int processId) {
        processes[processId].isSuspended = true;
        std::cout << "Process " << processId << " suspended." << std::endl;
    }

    // Function to resume a specific process
    void resumeProcess(int processId) {
        processes[processId].isSuspended = false;
        std::cout << "Process " << processId << " resumed." << std::endl;
    }

    // Function to terminate a specific process
    void terminateProcess(int processId) {
        processes[processId].isTerminated = true;
        std::cout << "Process " << processId << " terminated." << std::endl;
    }

    // Function to display detailed information about each process and its threads
    void displayProcessInformation() {
        for (const auto& process : processes) {
            std::cout << "Process ID: " << process.id << std::endl;
            std::cout << "Number of Threads: " << process.threads.size() << std::endl;
            std::cout << "Is Suspended: " << (process.isSuspended ? "Yes" : "No") << std::endl;
            std::cout << "Is Terminated: " << (process.isTerminated ? "Yes" : "No") << std::endl;
            for (const auto& thread : process.threads) {
                std::cout << "  Thread ID: " << thread.get_id() << std::endl;
            }
            std::cout << std::endl;
        }
    }

private:
    // Sample thread function
    void threadFunction(int processId, int threadId) {
        std::cout << "Thread " << threadId << " in Process " << processId << " started." << std::endl;
        // Simulate some work
        sleep(2);
        std::cout << "Thread " << threadId << " in Process " << processId << " finished." << std::endl;
    }
};

int main() {
    ThreadManager threadManager;

    // Create some processes and threads
    threadManager.createProcess(0);
    threadManager.createThread(0, 0);
    threadManager.createThread(0, 1);
    threadManager.createThread(0, 2);

    // Start threads in process 0
    threadManager.startProcessThreads(0);

    // Display process information
    threadManager.displayProcessInformation();

    return 0;
}
